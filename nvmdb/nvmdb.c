#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>

#define PORT	27017

#define OP_MSG		2013
#define OP_REPLY	1
#define OP_QUERY	2004

#define TYPE_NONE	0
#define TYPE_STRING	2
#define TYPE_DOCUMENT	3

struct MsgHeader {
    int32_t   messageLength; // total message size, including this
    int32_t   requestID;     // identifier for this message
    int32_t   responseTo;    // requestID from the original request
    int32_t   opCode;        // message type
};

struct Op_Query {
  struct MsgHeader header;                 // standard message header
  int32_t     flags;                  // bit values of query options.
  char	      fullCollectionName[20];	// reservation-db.$cmd
  int32_t     numberToSkip;           // number of documents to skip
  int32_t     numberToReturn;         // number of documents to return in the first OP_REPLY batch
  int32_t	length;
};

struct Op_Reply {
  struct MsgHeader header;         // standard message header
  int32_t     responseFlags;  // bit values - see details below
  int64_t     cursorID;       // cursor id if client needs to do get more's
  int32_t     startingFrom;   // where in the cursor this reply is starting
  int32_t     numberReturned; // number of documents in the reply
  int32_t	length;
};

static char in1_bytes[] = {
  0x3a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xd4, 0x07, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x61, 0x64, 0x6d, 0x69,
  0x6e, 0x2e, 0x24, 0x63, 0x6d, 0x64, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x13,
  0x00, 0x00, 0x00, 0x10, 0x67, 0x65, 0x74, 0x6e,
  0x6f, 0x6e, 0x63, 0x65, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x00
};

static char out1_bytes[] = {
  0x51, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00,
  0x02, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x00, 0x11,
  0x00, 0x00, 0x00, 0x33, 0x34, 0x34, 0x33, 0x35,
  0x33, 0x61, 0x66, 0x66, 0x31, 0x66, 0x39, 0x64,
  0x61, 0x37, 0x34, 0x00, 0x01, 0x6f, 0x6b, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
  0x00
};

static char in2_bytes[] = {
  0x3a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xd4, 0x07, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x61, 0x64, 0x6d, 0x69,
  0x6e, 0x2e, 0x24, 0x63, 0x6d, 0x64, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x13,
  0x00, 0x00, 0x00, 0x10, 0x69, 0x73, 0x6d, 0x61,
  0x73, 0x74, 0x65, 0x72, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x00
};

static char out2_bytes[] = {
  0x3f, 0x01, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x1b, 0x01, 0x00, 0x00,
  0x08, 0x69, 0x73, 0x6d, 0x61, 0x73, 0x74, 0x65,
  0x72, 0x00, 0x01, 0x03, 0x74, 0x6f, 0x70, 0x6f,
  0x6c, 0x6f, 0x67, 0x79, 0x56, 0x65, 0x72, 0x73,
  0x69, 0x6f, 0x6e, 0x00, 0x2d, 0x00, 0x00, 0x00,
  0x07, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73,
  0x49, 0x64, 0x00, 0x62, 0xdc, 0xd0, 0x4c, 0x47,
  0x37, 0xa0, 0x43, 0xf9, 0xe9, 0xf0, 0x46, 0x12,
  0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x10, 0x6d, 0x61, 0x78, 0x42, 0x73, 0x6f,
  0x6e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53,
  0x69, 0x7a, 0x65, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x10, 0x6d, 0x61, 0x78, 0x4d, 0x65, 0x73, 0x73,
  0x61, 0x67, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x42,
  0x79, 0x74, 0x65, 0x73, 0x00, 0x00, 0x6c, 0xdc,
  0x02, 0x10, 0x6d, 0x61, 0x78, 0x57, 0x72, 0x69,
  0x74, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x53,
  0x69, 0x7a, 0x65, 0x00, 0xa0, 0x86, 0x01, 0x00,
  0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x54, 0x69,
  0x6d, 0x65, 0x00, 0x4b, 0xa4, 0x8e, 0x2e, 0x82,
  0x01, 0x00, 0x00, 0x10, 0x6c, 0x6f, 0x67, 0x69,
  0x63, 0x61, 0x6c, 0x53, 0x65, 0x73, 0x73, 0x69,
  0x6f, 0x6e, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75,
  0x74, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x73,
  0x00, 0x1e, 0x00, 0x00, 0x00, 0x10, 0x63, 0x6f,
  0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
  0x49, 0x64, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10,
  0x6d, 0x69, 0x6e, 0x57, 0x69, 0x72, 0x65, 0x56,
  0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x10, 0x6d, 0x61, 0x78, 0x57,
  0x69, 0x72, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69,
  0x6f, 0x6e, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08,
  0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79,
  0x00, 0x00, 0x01, 0x6f, 0x6b, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f, 0x00
};

static char in3_bytes[] = {
  0x36, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xd4, 0x07, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x61, 0x64, 0x6d, 0x69,
  0x6e, 0x2e, 0x24, 0x63, 0x6d, 0x64, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x0f,
  0x00, 0x00, 0x00, 0x10, 0x70, 0x69, 0x6e, 0x67,
  0x00, 0x01, 0x00, 0x00, 0x00, 0x00
};

static char out3_bytes[] = {
  0x35, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
  0x01, 0x6f, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xf0, 0x3f, 0x00
};

static char count_response[] = {
  0x3c, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
  0x10, 0x6e, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
  0x6f, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xf0, 0x3f, 0x00
};

static int connfd;

static void respond(struct Op_Reply *response, ssize_t size, struct Op_Query *query)
{
  static int32_t requestID = 7;

  response->header.requestID = requestID++;
  response->header.responseTo = query->header.requestID;

  ssize_t len = send(connfd, response, size, 0);
  assert(len == size);
}

static char *parse(char *buf, char *end, struct Op_Query *query)
{
  for(char *b = buf; b < end;) {
    uint8_t *kind = b++;

    switch(*kind) {
    case TYPE_NONE:
      b++;
      break;

    case TYPE_STRING:
      {
	size_t tlen = strlen(b) + 1;
	char *sn = b;
	int32_t *len = (void *)(b + tlen);
	char *sv = b + tlen + sizeof(int32_t);
	fprintf(stderr, "Got string (%s): len = %d, %s\n", sn, *len, sv);
	b += tlen + sizeof(int32_t) + *len;
	if(!strcmp(sn, "count")) {
	  fprintf(stderr, "Sending count response\n");
	  respond((struct Op_Reply *)count_response, sizeof(count_response), query);
	  return end;	// XXX: Stopping parsing right away
	}
      }
      break;

    case TYPE_DOCUMENT:
      {
	size_t tlen = strlen(b) + 1;
	char *sn = b;
	fprintf(stderr, "Got document (%s)\n", sn);
	int32_t *dlen = (void *)(b + tlen);
	// Recurse
	b = parse(b + tlen + sizeof(int32_t), b + tlen + sizeof(int32_t) + *dlen, query);
      }
      break;

    default:
      assert(!"NYI");
      break;
    }
  }

  return end;
}

int main(int argc, char *argv[])
{
  struct sockaddr_in servaddr, cli;

  // socket create and verification
  int sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd == -1) {
    perror("socket");
    exit(EXIT_FAILURE);
  }
   
  // assign IP, PORT
  bzero(&servaddr, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
  servaddr.sin_port = htons(PORT);

  // Binding newly created socket to given IP and verification
  if ((bind(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr))) != 0) {
    perror("bind");
    exit(EXIT_FAILURE);
  }

  // Now server is ready to listen and verification
  if ((listen(sockfd, 5)) != 0) {
    perror("listen");
    exit(EXIT_FAILURE);
  }

  int len = sizeof(cli);
  connfd = accept(sockfd, (struct sockaddr *)&cli, &len);
  if (connfd < 0) {
    perror("accept");
    exit(EXIT_FAILURE);
  }

  // Handshake
#define MAX_BUF	4096
  static char buf[MAX_BUF];

  ssize_t n = read(connfd, buf, sizeof(in1_bytes));
  assert(n == sizeof(in1_bytes));
  if(memcmp(buf, in1_bytes, sizeof(in1_bytes) != 0)) {
    fprintf(stderr, "Received: ");
    for(int i = 0; i < sizeof(in1_bytes); i++) {
      fprintf(stderr, "%x ", buf[i]);
    }
    fprintf(stderr, "\n");
    exit(EXIT_FAILURE);
  }
  n = write(connfd, out1_bytes, sizeof(out1_bytes));
  assert(n == sizeof(out1_bytes));

  n = read(connfd, buf, sizeof(in2_bytes));
  assert(n == sizeof(in2_bytes));
  if(memcmp(buf, in2_bytes, sizeof(in2_bytes) != 0)) {
    fprintf(stderr, "Received: ");
    for(int i = 0; i < sizeof(in2_bytes); i++) {
      fprintf(stderr, "%x ", buf[i]);
    }
    fprintf(stderr, "\n");
    exit(EXIT_FAILURE);
  }
  n = write(connfd, out2_bytes, sizeof(out2_bytes));
  assert(n == sizeof(out2_bytes));

  n = read(connfd, buf, sizeof(in3_bytes));
  assert(n == sizeof(in3_bytes));
  if(memcmp(buf, in3_bytes, sizeof(in3_bytes) != 0)) {
    fprintf(stderr, "Received: ");
    for(int i = 0; i < sizeof(in3_bytes); i++) {
      fprintf(stderr, "%x ", buf[i]);
    }
    fprintf(stderr, "\n");
    exit(EXIT_FAILURE);
  }
  n = write(connfd, out3_bytes, sizeof(out3_bytes));
  assert(n == sizeof(out3_bytes));

  for(;;) {
    struct Op_Query *q = (void *)buf;
    int n = read(connfd, buf, sizeof(struct Op_Query));

    // Assert it's a query (that's all I know how to process)
    assert(n == sizeof(struct Op_Query));
    assert(q->header.opCode == OP_QUERY);

    // Read the remaining query
    int rn = read(connfd, buf + sizeof(struct Op_Query), q->header.messageLength - sizeof(struct Op_Query));
    assert(rn == q->header.messageLength - sizeof(struct Op_Query));
    // Has to be to the reservation-db
    assert(memcmp(q->fullCollectionName, "reservation-db.$cmd", 20) == 0);

    fprintf(stderr, "Received: ");
    for(int i = 0; i < n + rn; i++) {
      fprintf(stderr, "%x ", buf[i]);
    }
    fprintf(stderr, "\n");
    fprintf(stderr, "n = %d, %.*s\n", n, n, buf);
    fprintf(stderr, "len = %u\n", q->header.messageLength);

    // Parse query
    /* fprintf(stderr, "Sleeping...\n"); */
    /* sleep(20); */
    fprintf(stderr, "Parsing...\n");
    char *nb = parse(&buf[sizeof(struct Op_Query)], &buf[sizeof(struct Op_Query) + q->length], q);
    assert(nb == &buf[sizeof(struct Op_Query) + q->length]);
    fprintf(stderr, "Done parsing\n");
  }

  return EXIT_SUCCESS;
}
