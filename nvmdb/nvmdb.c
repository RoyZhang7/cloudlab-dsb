#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <pthread.h>
#include <stdbool.h>

#define DEBUG(fmt, ...) \
  fprintf(stderr, "connfd %d: " fmt, connfd, ##__VA_ARGS__);

#define PORT		27017
#define MAX_BUF		4096

#define OP_MSG		2013
#define OP_REPLY	1
#define OP_QUERY	2004

#define TYPE_NONE	0
#define TYPE_STRING	2
#define TYPE_DOCUMENT	3
#define TYPE_ARRAY	4
#define TYPE_BOOLEAN	8
#define TYPE_INT32	0x10

struct MsgHeader {
    int32_t   messageLength; // total message size, including this
    int32_t   requestID;     // identifier for this message
    int32_t   responseTo;    // requestID from the original request
    int32_t   opCode;        // message type
}  __attribute__((packed));

struct Op_Query {
  struct MsgHeader header;                 // standard message header
  int32_t     flags;                  // bit values of query options.
  char	      fullCollectionName[20];	// reservation-db.$cmd
  int32_t     numberToSkip;           // number of documents to skip
  int32_t     numberToReturn;         // number of documents to return in the first OP_REPLY batch
  int32_t	length;
} __attribute__((packed));

struct Admin_Op_Query {
  struct MsgHeader header;                 // standard message header
  int32_t     flags;                  // bit values of query options.
  char	      fullCollectionName[11];	// admin.$cmd
  int32_t     numberToSkip;           // number of documents to skip
  int32_t     numberToReturn;         // number of documents to return in the first OP_REPLY batch
  int32_t	length;
}  __attribute__((packed));

struct Op_Reply {
  struct MsgHeader header;         // standard message header
  int32_t     responseFlags;  // bit values - see details below
  int64_t     cursorID;       // cursor id if client needs to do get more's
  int32_t     startingFrom;   // where in the cursor this reply is starting
  int32_t     numberReturned; // number of documents in the reply
  int32_t	length;
}  __attribute__((packed));

static char getnonce_response[] = {
  0x51, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00,
  0x02, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x00, 0x11,
  0x00, 0x00, 0x00, 0x33, 0x34, 0x34, 0x33, 0x35,
  0x33, 0x61, 0x66, 0x66, 0x31, 0x66, 0x39, 0x64,
  0x61, 0x37, 0x34, 0x00, 0x01, 0x6f, 0x6b, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
  0x00
};

static char ping_response[] = {
  0x35, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
  0x01, 0x6f, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xf0, 0x3f, 0x00
};

static char ismaster_response[] = {
  0x3f, 0x01, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x1b, 0x01, 0x00, 0x00,
  0x08, 0x69, 0x73, 0x6d, 0x61, 0x73, 0x74, 0x65,
  0x72, 0x00, 0x01, 0x03, 0x74, 0x6f, 0x70, 0x6f,
  0x6c, 0x6f, 0x67, 0x79, 0x56, 0x65, 0x72, 0x73,
  0x69, 0x6f, 0x6e, 0x00, 0x2d, 0x00, 0x00, 0x00,
  0x07, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73,
  0x49, 0x64, 0x00, 0x62, 0xdc, 0xd0, 0x4c, 0x47,
  0x37, 0xa0, 0x43, 0xf9, 0xe9, 0xf0, 0x46, 0x12,
  0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x10, 0x6d, 0x61, 0x78, 0x42, 0x73, 0x6f,
  0x6e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53,
  0x69, 0x7a, 0x65, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x10, 0x6d, 0x61, 0x78, 0x4d, 0x65, 0x73, 0x73,
  0x61, 0x67, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x42,
  0x79, 0x74, 0x65, 0x73, 0x00, 0x00, 0x6c, 0xdc,
  0x02, 0x10, 0x6d, 0x61, 0x78, 0x57, 0x72, 0x69,
  0x74, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x53,
  0x69, 0x7a, 0x65, 0x00, 0xa0, 0x86, 0x01, 0x00,
  0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x54, 0x69,
  0x6d, 0x65, 0x00, 0x4b, 0xa4, 0x8e, 0x2e, 0x82,
  0x01, 0x00, 0x00, 0x10, 0x6c, 0x6f, 0x67, 0x69,
  0x63, 0x61, 0x6c, 0x53, 0x65, 0x73, 0x73, 0x69,
  0x6f, 0x6e, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75,
  0x74, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x73,
  0x00, 0x1e, 0x00, 0x00, 0x00, 0x10, 0x63, 0x6f,
  0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
  0x49, 0x64, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10,
  0x6d, 0x69, 0x6e, 0x57, 0x69, 0x72, 0x65, 0x56,
  0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x10, 0x6d, 0x61, 0x78, 0x57,
  0x69, 0x72, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69,
  0x6f, 0x6e, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08,
  0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79,
  0x00, 0x00, 0x01, 0x6f, 0x6b, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f, 0x00
};

static char count_response[] = {
  0x3c, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
  0x10, 0x6e, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
  0x6f, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xf0, 0x3f, 0x00
};

static char createindexes_response[] = {
  0x84, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00,
  0xa9, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
  0x10, 0x6e, 0x75, 0x6d, 0x49, 0x6e, 0x64, 0x65,
  0x78, 0x65, 0x73, 0x42, 0x65, 0x66, 0x6f, 0x72,
  0x65, 0x00, 0x02, 0x00, 0x00, 0x00, 0x10, 0x6e,
  0x75, 0x6d, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x65,
  0x73, 0x41, 0x66, 0x74, 0x65, 0x72, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x02, 0x6e, 0x6f, 0x74, 0x65,
  0x00, 0x1a, 0x00, 0x00, 0x00, 0x61, 0x6c, 0x6c,
  0x20, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73,
  0x20, 0x61, 0x6c, 0x72, 0x65, 0x61, 0x64, 0x79,
  0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x00, 0x01,
  0x6f, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xf0, 0x3f, 0x00
};

static char find_response[] = {
  0x82, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00,
  0x03, 0x63, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x00,
  0x45, 0x00, 0x00, 0x00, 0x04, 0x66, 0x69, 0x72,
  0x73, 0x74, 0x42, 0x61, 0x74, 0x63, 0x68, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x00, 0x12, 0x69, 0x64,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x02, 0x6e, 0x73, 0x00, 0x1b, 0x00, 0x00,
  0x00, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61,
  0x74, 0x69, 0x6f, 0x6e, 0x2d, 0x64, 0x62, 0x2e,
  0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74,
  0x69, 0x6f, 0x6e, 0x00, 0x00, 0x01, 0x6f, 0x6b,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
  0x3f, 0x00
};

static char find_hotelid_response[] = {
  0xb7, 0x00, 0x00, 0x00, 0x5b, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00,
  0x03, 0x63, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x00,
  0x7a, 0x00, 0x00, 0x00, 0x04, 0x66, 0x69, 0x72,
  0x73, 0x74, 0x42, 0x61, 0x74, 0x63, 0x68, 0x00,
  0x3f, 0x00, 0x00, 0x00, 0x03, 0x30, 0x00, 0x37,
  0x00, 0x00, 0x00, 0x07, 0x5f, 0x69, 0x64, 0x00,
  0x62, 0xdc, 0xd0, 0x18, 0x4c, 0x5a, 0x39, 0x03,
  0x7c, 0xbf, 0x72, 0x8b, 0x02, 0x68, 0x6f, 0x74,
  0x65, 0x6c, 0x49, 0x64, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x39, 0x00, 0x10, 0x6e, 0x75, 0x6d, 0x62,
  0x65, 0x72, 0x4f, 0x66, 0x52, 0x6f, 0x6f, 0x6d,
  0x00, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12,
  0x69, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x02, 0x6e, 0x73, 0x00, 0x16,
  0x00, 0x00, 0x00, 0x72, 0x65, 0x73, 0x65, 0x72,
  0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2d, 0x64,
  0x62, 0x2e, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72,
  0x00, 0x00, 0x01, 0x6f, 0x6b, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f, 0x00
};

struct state {
  bool	find;
  char	hotelId[MAX_BUF], inDate[MAX_BUF], outDate[MAX_BUF];
};

static int __thread connfd;
static _Atomic int32_t requestID = 4;
static struct state __thread state;

static void respond(struct Op_Reply *response, ssize_t size, struct MsgHeader *h)
{
  response->header.requestID = requestID++;
  response->header.responseTo = h->requestID;

  ssize_t len = send(connfd, response, size, 0);
  assert(len == size);
}

static char *parse_admin(char *buf, char *end, struct Admin_Op_Query *query)
{
  for(char *b = buf; b < end;) {
    uint8_t *kind = b++;

    switch(*kind) {
    case TYPE_INT32:
      {
	size_t tlen = strlen(b) + 1;
	char *sn = b;
	DEBUG("Got int32 (%s).\n", sn);
	b += tlen;
	if(!strcmp(sn, "getnonce")) {
	  /* DEBUG("Sending getnonce response\n"); */
	  respond((struct Op_Reply *)getnonce_response, sizeof(getnonce_response), &query->header);
	  return end;	// XXX: Stopping parsing right away
	}

	if(!strcmp(sn, "ping")) {
	  /* DEBUG("Sending ping response\n"); */
	  respond((struct Op_Reply *)ping_response, sizeof(ping_response), &query->header);
	  return end;	// XXX: Stopping parsing right away
	}

	if(!strcmp(sn, "ismaster")) {
	  /* DEBUG("Sending ismaster response\n"); */
	  respond((struct Op_Reply *)ismaster_response, sizeof(ismaster_response), &query->header);
	  return end;	// XXX: Stopping parsing right away
	}
      }
      break;

    default:
      assert(!"NYI");
      break;
    }
  }

  return end;
}

static char *parse(char *buf, char *end, struct Op_Query *query)
{
  for(char *b = buf; b < end;) {
    uint8_t *kind = b++;

    switch(*kind) {
    case TYPE_NONE:
      b++;
      break;

    case TYPE_STRING:
      {
	size_t tlen = strlen(b) + 1;
	char *sn = b;
	int32_t *len = (void *)(b + tlen);
	char *sv = b + tlen + sizeof(int32_t);
	DEBUG("Got string (%s): len = %d, %s\n", sn, *len, sv);
	b += tlen + sizeof(int32_t) + *len;

	if(!strcmp(sn, "count")) {
	  /* DEBUG("Sending count response\n"); */
	  respond((struct Op_Reply *)count_response, sizeof(count_response), &query->header);
	  return end;	// XXX: Stopping parsing right away
	}
	if(!strcmp(sn, "createIndexes")) {
	  /* DEBUG("Sending createIndexes response\n"); */
	  respond((struct Op_Reply *)createindexes_response, sizeof(createindexes_response), &query->header);
	  return end;	// XXX: Stopping parsing right away
	}

	// Parse query
	if(!strcmp(sn, "outDate")) {
	  strcpy(state.outDate, sv);
	}
	if(!strcmp(sn, "inDate")) {
	  strcpy(state.inDate, sv);
	}
	if(!strcmp(sn, "hotelId")) {
	  strcpy(state.hotelId, sv);
	}
	if(!strcmp(sn, "find")) {
	  state.find = true;
	}
      }
      break;

    case TYPE_DOCUMENT:
    case TYPE_ARRAY:
      {
	size_t tlen = strlen(b) + 1;
	char *sn = b;
	DEBUG("Got document (%s)\n", sn);
	int32_t *dlen = (void *)(b + tlen);
	// Recurse
	b = parse(b + tlen + sizeof(int32_t), b + tlen + *dlen, query);
      }
      break;

    case TYPE_BOOLEAN:
      {
	size_t tlen = strlen(b) + 1;
	char *sn = b;
	DEBUG("Got boolean (%s).\n", sn);
	b += tlen + sizeof(int8_t);
      }
      break;

    case TYPE_INT32:
      {
	size_t tlen = strlen(b) + 1;
	char *sn = b;
	int32_t n = *(int32_t *)(b + tlen);
	DEBUG("Got int32 (%s) = %d.\n", sn, n);
	b += tlen + sizeof(int32_t);
	if(!strcmp(sn, "skip")) {
	  // Nothing to do
	  continue;
	}
      }
      break;

    default:
      assert(!"NYI");
      break;
    }
  }

  return end;
}

static void *server_thread(void *arg)
{
  // Handshake
  char buf[MAX_BUF];
  connfd = (intptr_t)arg;

  for(;;) {
    struct Op_Query *q = (void *)buf;
    int n = read(connfd, buf, sizeof(struct Op_Query));

    // Assert it's a query (that's all I know how to process)
    assert(n == sizeof(struct Op_Query) || n == sizeof(struct Admin_Op_Query));
    assert(q->header.opCode == OP_QUERY);

    // Read the remaining query
    int rn = read(connfd, buf + n, q->header.messageLength - n);
    assert(rn == q->header.messageLength - n);

    // Is it to the admin db?
    if(!memcmp(q->fullCollectionName, "admin.$cmd", 10)) {
      struct Admin_Op_Query *aq = (void *)buf;
      /* DEBUG("Parsing admin query...\n"); */
      char *nb = parse_admin(&buf[sizeof(struct Admin_Op_Query)], &buf[sizeof(struct Admin_Op_Query) + q->length], aq);
      assert(nb == &buf[sizeof(struct Admin_Op_Query) + q->length]);
      /* DEBUG("Done parsing\n"); */
    } else {
      // Has to be to the reservation-db
      assert(!memcmp(q->fullCollectionName, "reservation-db.$cmd", 20));

      /* DEBUG("Received: "); */
      /* for(int i = 0; i < n + rn; i++) { */
      /* 	fprintf(stderr, "%x ", buf[i]); */
      /* } */
      /* fprintf(stderr, "\n"); */
      /* DEBUG("n = %d, %.*s\n", n, n, buf); */
      /* DEBUG("len = %u\n", q->header.messageLength); */

      // Parse query
      /* DEBUG("Sleeping...\n"); */
      /* sleep(20); */
      /* DEBUG("Parsing...\n"); */

      memset(&state, 0, sizeof(struct state));

      char *nb = parse(&buf[sizeof(struct Op_Query)], &buf[sizeof(struct Op_Query) + q->length], q);
      assert(nb == &buf[sizeof(struct Op_Query) + q->length]);
      /* DEBUG("Done parsing\n"); */

      if(state.find) {
	fprintf(stderr, "find hotelId = '%s', inDate = '%s', outDate = '%s'\n",
	       state.hotelId, state.inDate, state.outDate);

	if(state.inDate[0] == '\0') {
	  respond((struct Op_Reply *)find_hotelid_response, sizeof(find_hotelid_response), &q->header);
	} else {
	  respond((struct Op_Reply *)find_response, sizeof(find_response), &q->header);
	}
      }
    }
  }

  return NULL;
}

int main(int argc, char *argv[])
{
  struct sockaddr_in servaddr, cli;

  fprintf(stderr, "NVMdb\n");

  // socket create and verification
  int sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd == -1) {
    perror("socket");
    exit(EXIT_FAILURE);
  }
   
  // assign IP, PORT
  bzero(&servaddr, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
  servaddr.sin_port = htons(PORT);

  // Binding newly created socket to given IP and verification
  if ((bind(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr))) != 0) {
    perror("bind");
    exit(EXIT_FAILURE);
  }

  // Now server is ready to listen and verification
  if ((listen(sockfd, 5)) != 0) {
    perror("listen");
    exit(EXIT_FAILURE);
  }

  // Keep accepting connections and spawning threads for them
  for(int i = 0;; i++) {
    int len = sizeof(cli);
    intptr_t connfd = accept(sockfd, (struct sockaddr *)&cli, &len);
    if (connfd < 0) {
      perror("accept");
      exit(EXIT_FAILURE);
    }

    fprintf(stderr, "New connection - spawning thread %d for connfd %ld\n", i, connfd);

    pthread_t t;
    int r = pthread_create(&t, NULL, server_thread, (void *)connfd);
    assert(r == 0);
  }

  return EXIT_SUCCESS;
}
